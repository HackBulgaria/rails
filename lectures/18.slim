---
layout: lecture
title: Action Job
---

section.center data-background="#000"
  h1.white Action Job

section.center data-background="#f00"
  p.white Questions

section.center
  pre: code.ruby contenteditable="true"
    '
      module Foo
        INSIDE = :foo
        module Bar
          INSIDE = :bar
          module Quux
            INSIDE = :quux
          end
        end
      end

      module Foo::Bar::Quux
        p Bar::INSIDE
      end

section.center
  pre: code.ruby contenteditable="true"
    '
      module Foo
        module Bar
          module Quux
            p Module.nesting
          end
        end
      end

section.center
  p Which parts of a Rails app are autoloaded?

section.center
  p Which is the base class for Rails mailers?

section.center
  p Where do mailers live?

section.center
  p What view formats do mailers support?

section.center
  p Is using URL helpers in mail views a good idea?

section.center
  p Some operations are slow

section.center
  p Running data analysis queries

section.center
  p Adding notifications for 1000 users

section.center
  p Some operations depend on external services

section.center
  p Sending mails

section.center
  p Fetching a batch of tweets

section.center
  p These operations could destroy the response time of an application

section.center
  p Such operations could be performed in the background, outside of the request/response cycle

section.center
  p ActiveJob

section.center
  p Interface for running tasks

section.center
  p In sequence

section.center
  p In parallel

section.center
  p In foregroung

section.center
  p In background

section.center
  p Actually, ActiveJob does not provide a concrete implementation

section.center
  p It's just an interface

section.center
  p Implementations come from gems

section.center
  p Changing implementations is free

section.center
  p app/jobs

section.center
  p rails generate job solutions_checker

section.center
  p ActiveJob::Base

section.center
  pre: code.ruby contenteditable="true"
    '
      class SolutionCheckerJob < ActiveJob::Base
        queue_as :default

        def perform(*args)
          # Implement heavy operation here.
        end
      end

section.center
  pre: code.ruby contenteditable="true"
    '
      SolutionCheckerJob.perform_later solution

section.center
  pre: code.ruby contenteditable="true"
    '
      SolutionCheckerJob.set(wait_until: Date.tomorrow.noon).perform_later(solution)

section.center
  pre: code.ruby contenteditable="true"
    '
      SolutionCheckerJob.set(wait: 1.week).perform_later(record)

section.center
  p: a(href="http://api.rubyonrails.org/classes/ActiveJob/QueueAdapters.html") Queue adapters

section.center
  pre: code.ruby contenteditable="true"
    '
      config.active_job.queue_adapter = :sidekiq

section.center
  p Callbacks

section.center
  pre: code.ruby contenteditable="true"
    '
      class SolutionCheckerJob < ActiveJob::Base
        queue_as :default

        before_enqueue do |job|
          # ...
        end

        def perform
          # ...
        end
      end

section.center
  pre:
    '
      before_enqueue
      around_enqueue
      after_enqueue
      before_perform
      around_perform
      after_perform

section.center
  p Action Mailer

section.center
  pre: code.ruby contenteditable="true"
    '
      TaskMailer.checked(@task, @user).deliver_now

section.center
   p Exceptions

section.center
  pre: code.ruby contenteditable="true"
    '
      class SolutionCheckerJob < ActiveJob::Base
        queue_as :default

        rescue_from(ActiveRecord::RecordNotFound) do |exception|
         # ...
        end

        def perform
          # ...
        end
      end

section.center
  p Queues

section.center
  pre: code.ruby contenteditable="true"
    '
      class SolutionCheckerJob < ActiveJob::Base
        queue_as :low_priority
        #....
      end

section.center
  pre: code.ruby contenteditable="true"
    '
      class SolutionCheckerJob < ActiveJob::Base
        queue_as do
          solution = self.arguments.first
          case solution.language
          when :ruby   then :ruby_checker_job
          when :python then :python_checker_job
          end
        end

        def perform(video)
          # ...
        end
      end

section.center
  pre: code.ruby contenteditable="true"
    '
      SolutionCheckerJob.set(queue: :high_priority).perform_later(solution)

section.center
  p: a(href="http://edgeguides.rubyonrails.org/active_job_basics.html") Action Job Basics

section.center
  img.inline src="/images/hackman.png"
